<!DOCTYPE html>
<html lang="en">

<head>
	<title>Holy-Meat</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
		body {
			font-family: Monospace;
			background-color: #ffffff;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}
	</style>
</head>

<body>


	<script src="js/three.js"></script>

	<script src="js/OrbitControls.js"></script>
	<script src="js/GLTFLoader.js"></script>

	<script src="js/Detector.js"></script>
	<script src="js/stats.js"></script>

	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();

		var container, controls;
		var camera, scene, renderer, light;
		var objects = [];
		var loader = new THREE.GLTFLoader();
		var tex = new THREE.TextureLoader().load('models/textures/Meat/Raw_meat.jpg');
		var kiwiTex = new THREE.TextureLoader().load('models/textures/Meat/Kiwi_Color.tga');

		init();
		animate();

		function init() {

			container = document.createElement('div');
			document.body.appendChild(container);

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(200, 200, 200);

			controls = new THREE.OrbitControls(camera);
			controls.target.set(0, 200, -0.2);
			controls.update();

			scene = new THREE.Scene();
			scene.add(new THREE.AmbientLight(0x0f0f0f));

			var light = new THREE.SpotLight(0xffffff, 1.5);
			light.position.set(0, 500, 2000);

			scene.add(light);

			// model
			var loader = new THREE.GLTFLoader();
			var tex = new THREE.TextureLoader().load('models/textures/Meat/Raw_meat.jpg');


			for (var i = 0; i < 100; i++) {
				loader.load('models/Meat.gltf', function(gltf) {

					gltf.scene.traverse(function(child) {

						if (child.isMesh) {

							// child.material.envMap = envMap;
							child.material.map = tex;
							child.position.x = Math.random() * 400 - 10;
							child.position.y = Math.random() * 400 - 10;
							child.position.z = Math.random() * 400 - 10;
							// child.rotation.x = Math.random() * 0 - 6;
							// child.rotation.y = Math.random() * 0 - 6;

							child.castShadow = true;
							child.receiveShadow = true;

						}

					});



					scene.add(gltf.scene);

					objects.push(gltf.scene);
				})
			}

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.gammaOutput = true;
			container.appendChild(renderer.domElement);

			window.addEventListener('resize', onWindowResize, false);
		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		document.querySelector('canvas').addEventListener('click', function(e) {
			for (var i = 0; i < 20; i++) {
				loader.load('models/Meat.gltf', function(gltf) {

					gltf.scene.traverse(function(child) {

						if (child.isMesh) {

							// child.material.envMap = envMap;
							child.material.map = tex;
							child.position.x = Math.random() * 400 - 0;
							child.position.y = Math.random() * 400 - 0;
							child.position.z = Math.random() * 400 - 0;
							// child.rotation.x = Math.random() * 0 - 6;
							// child.rotation.y = Math.random() * 0 - 6;

							child.castShadow = true;
							child.receiveShadow = true;

						}

					});



					scene.add(gltf.scene);

					objects.push(gltf.scene);
				})
			}

		})


		function animate() {

			requestAnimationFrame(animate);

			objects.forEach(function(object) {
				object.rotation.x += 0.001;
				object.rotation.y += 0.001;
			})



			renderer.render(scene, camera);

		}
	</script>

</body>

</html>
